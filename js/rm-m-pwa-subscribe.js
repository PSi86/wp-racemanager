// js/rm-m-pwa-subscribe.js
// Updated push subscription module with hybrid sessionStorage caching using admin-ajax.php
// Dependencies: rm-m-pilotSelector.js

import { pilotSelectInstance } from './rm-m-pilotSelector.js';

export class PushSubscription {
    constructor() {
        // Get config from the global inline script (generated by WordPress)
        const configData = (window.RmJsConfig && window.RmJsConfig["pushSubscription"]) || {};
        if (!configData) {
            throw new Error("PushSubscription: Missing configuration data");
        }

        // Required configuration: nonce, public VAPID key, and admin-ajax URL.
        this.nonce = configData.nonce;
        this.publicVapid = configData.publicVapid;
        this.ajaxUrl = configData.ajaxUrl;

        // Dependency: pilot selector for race and pilot info
        this.pilotSelect = document.getElementById(`${pilotSelectInstance.pilotSelectorId}`);

        // Optional configuration properties
        this.formId = configData.formId || 'pilot-push-form';
        this.form = document.getElementById(`${this.formId}`);

        this.subscribeButtonId = configData.subscribeButtonId || 'subscribe-button';
        this.subscribeButton = document.getElementById(`${this.subscribeButtonId}`);

        this.subscriptionStatusId = configData.subscriptionStatusId || 'subscription-status';
        this.subscriptionStatus = document.getElementById(`${this.subscriptionStatusId}`);

        // Reference to the service worker registration
        this.swRegistration = null;

        this.initialize();
    }

    initialize() {
        // Disable the subscribe button until the service worker is ready.
        this.subscribeButton.disabled = true;
        this.pilotSelect.addEventListener('change', this.checkSubscriptionState.bind(this));

        // Check for necessary APIs: service workers and push notifications.
        if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
            this.setSubscriptionStatus('Push Not Supported In This Browser');
            return;
        }

        // Wait for the service worker to become ready.
        navigator.serviceWorker.ready
            .then((registration) => {
                this.swRegistration = registration;
                console.log('Service worker is ready:', registration);
                // Now check the subscription state using a hybrid (cache and server) approach.
                this.checkSubscriptionState();
            })
            .catch((error) => {
                console.error('Error getting serviceWorker.ready:', error);
                this.setSubscriptionStatus('Cannot register Service Worker.');
            });

        // If the form element exists, attach a submission event.
        if (this.form) {
            this.form.addEventListener('submit', this.handleSubscriptionForm.bind(this));
        }
        // Also attach a listener to the subscribe button.
        if (this.subscribeButton) {
            this.subscribeButton.addEventListener('click', this.handleSubscriptionForm.bind(this));
        }
    }

    // Check the current subscription state.
    async checkSubscriptionState() {
        if (!this.swRegistration) return;
        const subscription = await this.swRegistration.pushManager.getSubscription();
        if (!subscription) {
            this.setSubscriptionStatus('Not subscribed.');
            this.subscribeButton.value = 'Subscribe';
            this.subscribeButton.disabled = false;
            sessionStorage.removeItem('rm_push_subscription_status');
            return;
        }
        // Try to get the cached subscription status from sessionStorage.
        const cachedStatus = this.getCachedSubscriptionStatus();
        if (cachedStatus) {
            this.updateSubscriptionUI(cachedStatus);
            return;
        }
        // If no cache is available, query the server.
        this.querySubscriptionStatusFromServer(subscription);
    }

    // Retrieve cached subscription status from localStorage.
    getCachedSubscriptionStatus() {
        const data = localStorage.getItem('rm_push_subscription_status');
        if (!data) return null;
        const parsed = JSON.parse(data);
        // If cache is older than 24 hours, clear it and return null.
        if (Date.now() - parsed.timestamp > 86400000) { // 24 hours in milliseconds
            localStorage.removeItem('rm_push_subscription_status');
            return null;
        }
        return parsed.data;
    }

    // Save subscription status in localStorage with a current timestamp.
    setCachedSubscriptionStatus(data) {
        const toStore = { data: data, timestamp: Date.now() };
        localStorage.setItem('rm_push_subscription_status', JSON.stringify(toStore));
    }

    // Query the server for the subscription status via the admin-ajax.php endpoint.
    async querySubscriptionStatusFromServer(subscription) {
        const endpoint = subscription.toJSON().endpoint;
        const formData = new URLSearchParams();
        formData.append('_ajax_nonce', this.nonce);
        formData.append('action', 'get_subscription');
        formData.append('endpoint', endpoint);
        
        try {
            const response = await fetch(this.ajaxUrl, {
                method: 'POST',
                body: formData
            });
            if (!response.ok) {
                throw new Error('Error fetching subscription status');
            }
            const json = await response.json();
            if (json.success) {
                this.setCachedSubscriptionStatus(json.data);
                this.updateSubscriptionUI(json.data);
            } else {
                this.setSubscriptionStatus('Error retrieving subscription status.');
                this.subscribeButton.disabled = false;
            }
        } catch (err) {
            console.error('Error fetching subscription status from server:', err);
            this.subscribeButton.disabled = false;
        }
    }
    
    // Update the UI based on the subscription status.
    updateSubscriptionUI(statusData) {
        // Retrieve the currently selected race from the pilot selector.
        const pilotOption = this.pilotSelect.selectedOptions[0];
        const currentRaceId = pilotOption ? pilotOption.getAttribute('data-race-id') : null;
        if (statusData.subscribed) {
            this.setSubscriptionStatus(`Subscribed to: ${statusData.race_title} -> ${statusData.pilot_callsign}`);
            if (statusData.race_id == currentRaceId && statusData.pilot_id == pilotOption.getAttribute('data-pilot-id')) {
                this.subscribeButton.value = 'Unsubscribe';
            } else {
                //this.setSubscriptionStatus(`Subscribed to race: ${statusData.race_id} (Current race: ${statusData.race_title})`);
                this.subscribeButton.value = 'Update Subscription';
            }
        } else {
            this.setSubscriptionStatus('Not subscribed.');
            this.subscribeButton.value = 'Subscribe';
        }
        this.subscribeButton.disabled = false;
    }

    // Handler for the subscription form/button.
    async handleSubscriptionForm(evt) {
        evt.preventDefault();
        this.subscribeButton.disabled = true;

        if (!this.swRegistration) {
            this.setSubscriptionStatus('Service Worker registration not available.');
            this.subscribeButton.disabled = false;
            return;
        }

        let subscription = await this.swRegistration.pushManager.getSubscription();

        if (!subscription) {
            // No subscription exists, so request a new one.
            // Even for unsubscribing we need to have a subscription object.
            subscription = await this.subscribeUser();
            if (!subscription) {
                this.subscribeButton.disabled = true;
                return;
            }
            // After obtaining a new subscription, send it to the server.
            //await this.sendSubscriptionToServer(newSubscription);
            //this.subscribeButton.disabled = false;
            //return;
        }

        // Subscription exists.
        // Determine action based on the button text:
        // If the button reads "Unsubscribe", then unsubscribe.
        // If it reads either "Subscribe" or "Update Subscription", send (or update) the subscription to the server.
        const btnText = this.subscribeButton.value;
        if (btnText === 'Unsubscribe') {
            await this.unsubscribeUser(subscription);
        } else if (btnText === 'Subscribe' || btnText === 'Update Subscription') {
            await this.sendSubscriptionToServer(subscription);
            this.subscribeButton.value = 'Unsubscribe';
        }
        this.subscribeButton.disabled = false;
        return;
        
    }

    // Subscribe the user (client-side subscription).
    async subscribeUser() {
        let sub = null;
        try {
            const permission = await Notification.requestPermission();
            if (permission !== 'granted') {
                this.setSubscriptionStatus('Permission Not Granted.');
                return null;
            }
            const convertedVapidKey = this.urlBase64ToUint8Array(this.publicVapid);
            sub = await this.swRegistration.pushManager.subscribe({
                userVisibleOnly: true,
                applicationServerKey: convertedVapidKey
            });
            console.log('Subscribed successfully:', sub);
            this.setSubscriptionStatus('Client-side subscription successful.');
            // We set to "Unsubscribe" because the browser now holds a subscription,
            // even if it might not yet be registered on the server.
            //this.subscribeButton.value = 'Unsubscribe';
        } catch (err) {
            console.error('Error during client-side subscription', err);
            this.setSubscriptionStatus('Client-side subscription error.');
            return null;
        }
        return sub;
    }

    // Unsubscribe the user and notify the server.
    async unsubscribeUser(subscription) {
        try {
            // Unsubscribe on the client.
            await subscription.unsubscribe();
            this.setSubscriptionStatus('Unsubscribed successfully.');
            this.subscribeButton.value = 'Subscribe';

            const endpoint = subscription.toJSON().endpoint;

            const formData = new URLSearchParams();
            formData.append('_ajax_nonce', this.nonce);
            formData.append('action', 'unsubscribe');
            formData.append('endpoint', endpoint);
            
            const response = await fetch(this.ajaxUrl, {
                method: 'POST',
                body: formData
            });
            if (!response.ok) {
                const errJson = await response.json();
                console.error('Server responded with error on unsubscribe:', errJson);
                this.setSubscriptionStatus('Error removing subscription on server.');
            } else {
                this.setSubscriptionStatus('Subscription removed from server.');
                // Update the cache to indicate not subscribed.
                this.setCachedSubscriptionStatus({ subscribed: false });
            }
        } catch (err) {
            console.error('Failed to unsubscribe', err);
            this.setSubscriptionStatus('Unsubscribe error.');
        }
    }

    // Send or update the subscription data along with race and pilot details to the server.
    async sendSubscriptionToServer(subscription) {
        const subObj = subscription.toJSON();
        const p256dh = (subObj.keys && subObj.keys.p256dh) ? subObj.keys.p256dh : '';
        const auth = (subObj.keys && subObj.keys.auth) ? subObj.keys.auth : '';

        // Get race and pilot info from the pilot selector.
        const pilotOption = this.pilotSelect.selectedOptions[0];
        const pilotId = pilotOption.getAttribute('data-pilot-id');
        const pilotCallsign = pilotOption.getAttribute('data-pilot-callsign');
        const raceId = pilotOption.getAttribute('data-race-id');

        if (!raceId || !pilotId) {
            this.setSubscriptionStatus('Please select a valid pilot first.');
            return;
        }

        try {
            const endpoint = subscription.toJSON().endpoint;
            const formData = new URLSearchParams();
            formData.append('_ajax_nonce', this.nonce);
            formData.append('action', 'update_subscription');
            formData.append('endpoint', endpoint);
            formData.append('race_id', raceId);
            formData.append('pilot_id', pilotId);
            formData.append('pilot_callsign', pilotCallsign);
            formData.append('keys[p256dh]', p256dh);
            formData.append('keys[auth]', auth);
            //formData.append('keys', JSON.stringify({ p256dh, auth }));

            const response = await fetch(this.ajaxUrl, {
                method: 'POST',
                body: formData
            });
            if (!response.ok) {
                throw new Error('Server returned ' + response.status);
            }
            const json = await response.json();
            if (json.data.race_title) {
                this.setSubscriptionStatus('Server subscription success: ' + json.data.race_title + ' -> ' + json.data.pilot_callsign);
            }
            else {
                this.setSubscriptionStatus('Server subscription success.');
            }
            // Update cache with subscription data.
            //this.setCachedSubscriptionStatus({ subscribed: true, race_id: raceId });
            this.setCachedSubscriptionStatus(json.data);
        } catch (err) {
            console.error('Sending subscription failed:', err);
            this.setSubscriptionStatus('Could not send subscription to server.');
        }
    }

    // Utility: Convert a base64 string to a UInt8Array (for VAPID key).
    urlBase64ToUint8Array(base64String) {
        const padding = '='.repeat((4 - base64String.length % 4) % 4);
        const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
        const rawData = window.atob(base64);
        const outputArray = new Uint8Array(rawData.length);
        for (let i = 0; i < rawData.length; ++i) {
            outputArray[i] = rawData.charCodeAt(i);
        }
        return outputArray;
    }

    // Set the subscription status text on the page.
    setSubscriptionStatus(message) {
        if (this.subscriptionStatus) {
            this.subscriptionStatus.textContent = message;
        } else {
            console.log('[SubscriptionStatus]', message);
        }
    }
}

export const pushSubscriptionInstance = new PushSubscription();
