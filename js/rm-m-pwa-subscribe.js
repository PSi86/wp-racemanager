// js/rm-m-pwa-subscribe.js
// PushSubscription: Subscribe to push notifications
// Handle subscription process and send subscription data to server
// Dependencies: rm-m-pilotSelector.js

import { pilotSelectInstance } from './rm-m-pilotSelector.js';

export class PushSubscription {
    constructor() {
        // Get config from the global inline script (generated by WordPress)
        const configData = (window.RmJsConfig && window.RmJsConfig["pushSubscription"]) || {};
        if(!configData) {
            throw new Error("PushSubscription: Missing configuration data");
        }

        // Configuration properties
        // Required properties
        this.nonce = configData.nonce;
        this.publicVapid = configData.publicVapid;
        this.restUrlSubscribe = configData.restUrlSubscribe;

        // Read dependency configuration
        this.pilotSelect = document.getElementById(`${pilotSelectInstance.pilotSelectorId}`); // Load pilotSelectorId from pilotSelector

        // Optional properties
        this.formId = configData.formId || 'pilot-push-form';
        this.form = document.getElementById(`${this.formId}`);

        this.subscribeButtonId = configData.subscribeButtonId || 'subscribe-button';
        this.subscribeButton = document.getElementById(`${this.subscribeButtonId}`);

        this.subscriptionStatusId = configData.subscriptionStatusId || 'subscription-status';
        this.subscriptionStatus = document.getElementById(`${this.subscriptionStatusId}`);

        // References to elements on the page
        this.swRegistration = null;

        this.initialize();
        //document.addEventListener('DOMContentLoaded', this.initialize);
    }

    initialize() {
        // will be re-enabled when browser supports push and service worker is registered
        this.subscribeButton.disabled = true;

        // Check if browser supports push
        if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
            this.setSubscriptionStatus('Push Not Supported In This Browser');
            //this.subscribeButton.disabled = true;
            return;
        }

        // Register service worker
        //navigator.serviceWorker.register('/wp/pwa-sw.js?ver=1.0.3')
        navigator.serviceWorker.ready
            .then(function (registration) {
                pushSubscriptionInstance.swRegistration = registration;
                console.log('Service worker is ready:', registration);
                pushSubscriptionInstance.checkSubscriptionState();
            })
            .catch(function (error) {
                console.error('Error getting serviceWorker.ready:', error);
                pushSubscriptionInstance.setSubscriptionStatus('Cannot register Service Worker.');
            });

        // If the form exists, attach the submission event
        if (this.form) {
            this.form.addEventListener('submit', this.handleSubscriptionForm);
        }
    }

    // Check current subscription status
    async checkSubscriptionState() {
        if (!this.swRegistration) {
            //this.subscribeButton.disabled = true;
            return;
        }
        const subscription = await this.swRegistration.pushManager.getSubscription();
        if (!subscription) {
            // Not subscribed
            this.setSubscriptionStatus('Not subscribed.');
            this.subscribeButton.textContent = 'Subscribe';
            this.subscribeButton.disabled = false;
        } else {
            // Already subscribed
            this.setSubscriptionStatus('Already subscribed.');
            this.subscribeButton.textContent = 'Unsubscribe';
            this.subscribeButton.disabled = false;
        }
    }

    // Handle the form submission (subscribe or unsubscribe)
    // Error when using "this"
    // ...seems to be called out of context by the form event
    // TODO: investigate why this is happening, change event listener registration? (arrow function?)
    async handleSubscriptionForm(evt) {
        evt.preventDefault();
        pushSubscriptionInstance.subscribeButton.disabled = true;

        if (!pushSubscriptionInstance.swRegistration) {
            pushSubscriptionInstance.setSubscriptionStatus('Service Worker registration not available.');
            pushSubscriptionInstance.subscribeButton.disabled = false;
            return;
        }

        let subscription = await pushSubscriptionInstance.swRegistration.pushManager.getSubscription();
        if (!subscription) {
            // Attempt to subscribe
            subscription = await pushSubscriptionInstance.subscribeUser();
            if (!subscription) return; // subscription failed or was blocked
            else  {
                // Send subscription data to server
                await pushSubscriptionInstance.sendSubscriptionToServer(subscription);
                pushSubscriptionInstance.subscribeButton.disabled = false;
            }
        } else {
            // If user is "already subscribed," let's handle unsubscribe logic
            if (pushSubscriptionInstance.subscribeButton.textContent === 'Unsubscribe') {
                await pushSubscriptionInstance.unsubscribeUser(subscription);
                pushSubscriptionInstance.subscribeButton.disabled = false;
                return;
            }
        }
    }

    // Subscribe user
    async subscribeUser() {
        let sub = null;
        try {
            const permission = await Notification.requestPermission();
            if (permission !== 'granted') {
                this.setSubscriptionStatus('Permission Not Granted.');
                return null;
            }

            const convertedVapidKey = this.urlBase64ToUint8Array(this.publicVapid);
            sub = await this.swRegistration.pushManager.subscribe({
                userVisibleOnly: true,
                applicationServerKey: convertedVapidKey
            });
            console.log('Subscribed successfully:', sub);

            this.setSubscriptionStatus('Client-side subscription successful.');
            this.subscribeButton.textContent = 'Unsubscribe';
        } catch (err) {
            console.error('Error during client-side subscription', err);
            this.setSubscriptionStatus('Could not subscribe.');
            return null;
        }
        return sub;
    }

    async unsubscribeUser(subscription) {
        try {
            // 1) unsubscribe in the browser
            await subscription.unsubscribe();

            this.setSubscriptionStatus('Unsubscribed successfully.');
            this.subscribeButton.textContent = 'Subscribe';

            // 2) inform WordPress REST API so the DB record is removed
            // TODO: does it make a difference if we inform the server before or after unsubscribing in the browser?
            const subObj = subscription.toJSON();
            const endpoint = subObj.endpoint;

            // only pass endpoint to the server for deletion
            const bodyData = {
                endpoint: endpoint,
            };

            const response = await fetch(this.restUrlSubscribe, {
                method: 'DELETE',
                headers: { 
                    'Content-Type': 'application/json',
                    'X-WP-Nonce': this.nonce  // include the nonce header
                },
                body: JSON.stringify(bodyData),
            });

            if (!response.ok) {
                const errJson = await response.json();
                console.error('Server responded with error on unsub:', errJson);
                this.setSubscriptionStatus('Error removing subscription on server.');
            } else {
                this.setSubscriptionStatus('Subscription removed from server.');
            }

        } catch (err) {
            console.error('Failed to unsubscribe', err);
            this.setSubscriptionStatus('Unsubscribe error.');
        }

        //this.subscribeButton.disabled = false;
    }

    // Send subscription data to server
    async sendSubscriptionToServer(subscription) {
        const subObj = subscription.toJSON();
        const p256dh = (subObj.keys && subObj.keys.p256dh) ? subObj.keys.p256dh : '';
        const auth = (subObj.keys && subObj.keys.auth) ? subObj.keys.auth : '';

        const pilotOption = this.pilotSelect.selectedOptions[0];
        const pilotId = pilotOption.getAttribute('data-pilot-id');
        const raceId = pilotOption.getAttribute('data-race-id');

        if (!raceId || !pilotId) {
            this.setSubscriptionStatus('Please select a valid pilot first.');
            return;
        }

        await fetch(this.restUrlSubscribe, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'X-WP-Nonce': this.nonce  // include the nonce header
            },
            body: JSON.stringify({
                race_id: raceId,
                pilot_id: pilotId,
                endpoint: subscription.endpoint,
                keys: { p256dh, auth }
            })
        })
            .then((res) => {
                if (!res.ok) throw new Error('Server returned ' + res.status);
                return res.json();
            })
            .then((json) => {
                this.setSubscriptionStatus('Server subscription success: ' + json.message);
            })
            .catch((err) => {
                console.error('Sending subscription failed', err);
                this.setSubscriptionStatus('Could not send subscription to server.');
            });
        //this.subscribeButton.disabled = false;
    }

    // Utility: Convert VAPID key
    urlBase64ToUint8Array(base64String) {
        const padding = '='.repeat((4 - base64String.length % 4) % 4);
        const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
        const rawData = window.atob(base64);
        const outputArray = new Uint8Array(rawData.length);
        for (let i = 0; i < rawData.length; ++i) {
            outputArray[i] = rawData.charCodeAt(i);
        }
        return outputArray;
    }

    setSubscriptionStatus(message) {
        if (this.subscriptionStatus) {
            this.subscriptionStatus.textContent = message;
        } else {
            console.log('[SubscriptionStatus]', message);
        }
    }
}
export const pushSubscriptionInstance = new PushSubscription();